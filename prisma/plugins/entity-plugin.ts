import { type PluginOptions } from '@zenstackhq/sdk';
import { DataModel, DataModelAttribute, DataModelField, isDataModel, Model } from '@zenstackhq/sdk/ast';
import * as fs from 'fs/promises';
import * as path from 'path';

export const name = 'entity';

const generateHeader = (
  importPath: string,
  currentModelName: string,
): string => `/////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                     //
// This file is automatically generated by ZenStack Plugin and should not be manually updated. //
/////////////////////////////////////////////////////////////////////////////////////////////////

import { Type } from 'class-transformer';
${importPath ? `import { ${importPath} } from './index';\n` : ''}
`;

const hasAttribute = (attributes: string[] | undefined, attributeName: string): boolean => attributes?.includes(attributeName) || false;

const getInterfaceName = (dataModel: DataModel): string => {
  const attributes = dataModel.attributes?.map((attr: DataModelAttribute) => attr.decl.ref?.name);
  if (hasAttribute(attributes, '@@Entity')) return `${dataModel.name}Entity`;
  if (hasAttribute(attributes, '@@ValueObject')) return `${dataModel.name}VO`;
  return '';
};

const mysqlToTsTypeMap: Record<string, string> = {
  VARCHAR: 'string',
  CHAR: 'string',
  TEXT: 'string',
  INT: 'number',
  INTEGER: 'number',
  TINYINT: 'number',
  SMALLINT: 'number',
  MEDIUMINT: 'number',
  BIGINT: 'string',
  FLOAT: 'number',
  DOUBLE: 'number',
  DECIMAL: 'number',
  DATE: 'string',
  DATETIME: 'Date',
  TIMESTAMP: 'string',
  TIME: 'string',
  YEAR: 'number',
  BOOLEAN: 'boolean',
  STRING: 'string',
  JSON: 'any',
};

const getFieldType = (field: DataModelField): string => field.type.reference?.ref?.name || field.type.type.toLowerCase();

const getRelatedModel = (fieldType: string, model: Model): DataModel | undefined =>
  model.declarations.find((decl: any) => decl.name === fieldType && isDataModel(decl)) as DataModel | undefined;

const getRelatedType = (relatedModel: DataModel): string => {
  const attributes = relatedModel.attributes?.map((attr: DataModelAttribute) => attr.decl.ref?.name);
  if (hasAttribute(attributes, '@@Entity')) return `${relatedModel.name}Entity`;
  if (hasAttribute(attributes, '@@ValueObject')) return `${relatedModel.name}VO`;
  return '';
};

const mapFieldType = (field: DataModelField, model: Model): string[] => {
  const fieldType = getFieldType(field);
  let mappedType = '';

  if (field.type.reference) {
    const relatedModel = getRelatedModel(fieldType, model);
    if (relatedModel) {
      const relatedType = getRelatedType(relatedModel);
      mappedType = field.type.array ? `${relatedType}[]` : relatedType;
    }
  } else {
    mappedType = mysqlToTsTypeMap[fieldType.toUpperCase()] || fieldType;
    mappedType = field.type.array ? `${mappedType}[]` : mappedType;
  }

  // 옵셔널 필드 처리
  const types = [mappedType];
  return types;
};

const isNonVORelation = (field: DataModelField, model: Model): boolean => {
  const fieldType = field.type.reference?.ref?.name;
  if (!fieldType) return false;
  const relatedModel = getRelatedModel(fieldType, model);
  if (!relatedModel) return false;
  const attributes = relatedModel.attributes?.map((attr: DataModelAttribute) => attr.decl.ref?.name);
  return hasAttribute(attributes, '@@Entity');
};

const isRelationField = (field: DataModelField): boolean => !!field.type.reference;

const generateFieldDeclaration = (field: DataModelField, model: Model, isVO: boolean): string => {
  if (isVO && isRelationField(field)) {
    return '';
  }

  const fieldType = mapFieldType(field, model);
  const isRelation = isRelationField(field);
  const relatedModel = isRelation ? getRelatedModel(field.type.reference?.ref?.name, model) : null;
  const isRelatedVO = relatedModel
    ? hasAttribute(
        relatedModel.attributes?.map((attr: DataModelAttribute) => attr.decl.ref?.name),
        '@@ValueObject',
      )
    : false;

  const optionalMark = field.type.optional || (isRelation && !isRelatedVO) ? '?' : '';
  const typeDecorator = isRelation ? `  @Type(() => ${fieldType[0]})\n`.replace('[]', '') : '';
  return `${typeDecorator}  public readonly ${field.name}${optionalMark}: ${fieldType.join(' | ')};`;
};

const generateClassContent = (dataModel: DataModel, model: Model, isVO: boolean): string => {
  const interfaceName = getInterfaceName(dataModel);

  const sortFields = (a: DataModelField, b: DataModelField): number => {
    const aIsOptional = a.type.optional || (isRelationField(a) && !isVORelation(a, model));
    const bIsOptional = b.type.optional || (isRelationField(b) && !isVORelation(b, model));

    if (aIsOptional === bIsOptional) return 0;
    if (aIsOptional) return 1;
    return -1;
  };

  const fields = dataModel.fields.filter((field) => !(isVO && field.name === 'id')).sort(sortFields);

  const fieldDeclarations = fields
    .map((field) => generateFieldDeclaration(field, model, isVO))
    .filter((declaration) => declaration !== '')
    .join('\n');

  return `export class ${interfaceName} {
${fieldDeclarations}
}
\n`;
};

const isVORelation = (field: DataModelField, model: Model): boolean => {
  const fieldType = field.type.reference?.ref?.name;
  if (!fieldType) return false;
  const relatedModel = getRelatedModel(fieldType, model);
  if (!relatedModel) return false;
  const attributes = relatedModel.attributes?.map((attr: DataModelAttribute) => attr.decl.ref?.name);
  return hasAttribute(attributes, '@@ValueObject');
};

const generateModelContent = (dataModel: DataModel, model: Model): string => {
  const interfaceName = getInterfaceName(dataModel);
  const isVO = interfaceName.endsWith('VO');
  if (!interfaceName) return '';
  return generateClassContent(dataModel, model, isVO);
};

const writeToFile = async (content: string, outputDir: string, fileName: string): Promise<void> => {
  const outputPath = path.join(outputDir, `${fileName}.ts`);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, content);
};

const generateIndexContent = (interfaceNames: string[]): string => {
  return interfaceNames.map((name) => `export * from './${name}';`).join('\n') + '\n';
};

export default async function run(model: Model, options: PluginOptions): Promise<void> {
  const dataModels = model.declarations.filter(isDataModel);
  const outputDir = options.outputDir as string;
  if (!outputDir) {
    throw new Error('outputDir is not set');
  }

  const interfaceNames: string[] = [];

  for (const dataModel of dataModels) {
    const interfaceName = getInterfaceName(dataModel);
    if (interfaceName) {
      interfaceNames.push(interfaceName);

      const importPaths: Set<string> = new Set();

      // 관련 모델의 임포트 경로 수집
      dataModel.fields.forEach((field) => {
        if (field.type.reference) {
          const relatedModel = getRelatedModel(field.type.reference.ref?.name, model);
          if (relatedModel) {
            const relatedType = getRelatedType(relatedModel);
            if (relatedType && relatedType !== interfaceName) {
              importPaths.add(relatedType);
            }
          }
        }
      });

      const importPath = Array.from(importPaths).join(', ');
      const content = generateHeader(importPath, interfaceName) + generateModelContent(dataModel, model);
      await writeToFile(content, outputDir, interfaceName);
    }
  }

  // index.ts 파일 생성
  const indexContent = generateIndexContent(interfaceNames);
  await writeToFile(indexContent, outputDir, 'index');
}
